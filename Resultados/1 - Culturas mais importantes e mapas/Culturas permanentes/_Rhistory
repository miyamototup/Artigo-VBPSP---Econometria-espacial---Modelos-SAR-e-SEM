#write.csv(princptemp2014,file="Culturas temporárias mais importantes - 2014",row.names=F)
#latex(head(princptemp2014,15),rowname=NULL)
princptemp1994=princptemp1994[,c(1,3)]
princptemp2014=princptemp2014[,c(1,3)]
princptemp=cbind(princptemp1994,princptemp2014)
colnames(princptemp)=c("Main products-1994","Value","Main products-2014","Value" )
#latex(head(princptemp,15),rowname=NULL)
View(princptemp2014)
principaispermanentes=read.csv("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Lavoura permanente/principais produtos da agricultura permanente_1994 e 2014.csv",header=T,na.strings=c("-","NA"))
princperm=aggregate(principaispermanentes[,c(4)],by=list(Produtor=principaispermanentes$Lavoura.permanente,Ano=principaispermanentes$Ano),sum,na.rm=T)
#1994
princperm1994=princperm[c(1:35),]
princperm1994=princperm1994[order(-princperm1994$x),]
colnames(princperm1994)[3]="Valor"
#setwd("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Resultados/1 - Culturas mais importantes e mapas/Culturas permanentes")
#write.csv(princperm1994,file="Culturas permanetes mais importantes 1994",row.names=F)
#latex(head(princperm1994,15),rowname=NULL)
#2014
princperm2014=princperm[c(36:70),]
princperm2014=princperm2014[order(-princperm2014$x),]
colnames(princperm2014)[3]="Valor"
#Excluir café total
princperm2014=princperm2014[c(1,3:35),]
setwd("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Resultados/1 - Culturas mais importantes e mapas/Culturas permanentes")
#write.csv(princperm2014,file="Culturas permanetes mais importantes 2014",row.names=F)
#latex(head(princperm2014,15),rowname=NULL)
princperm1994=princperm1994[c(1:34),c(1,3)]
princperm2014=princperm2014[,c(1,3)]
princperm=cbind(princperm1994,princperm2014)
colnames(princperm)=c("Main products-1994","Value","Main products-2014","Value" )
#latex(head(princperm,15),rowname=NULL)
###Tratar os dados para mostrarem a participação dos municípios
#Culturas permanentes
munperm=aggregate(principaispermanentes[,c(4)],by=list(Municipio=principaispermanentes$Município,
Ano=principaispermanentes$Ano),sum,na.rm=T)
munperml=split(munperm,paste(munperm$Ano))
munperml[[1]]$Perc=(munperml[[1]]$x)/(sum(munperml[[1]]$x))
munperml[[1]]$Perc=munperml[[1]]$Perc*100
#munperml[[1]]$Perc=format(munperml[[1]]$Perc,scientific=F)
munperml[[2]]$Perc=(munperml[[2]]$x)/(sum(munperml[[2]]$x))
#munperml[[2]]$Perc=format(munperml[[2]]$Perc,scientific=F)
munperml[[2]]$Perc=munperml[[2]]$Perc*100
#Culturas temporárias
muntemp=aggregate(principaistemporarias[,c(4)],by=list(Municipio=principaistemporarias$Município,
Ano=principaistemporarias$Ano),sum,na.rm=T)
muntempl=split(muntemp,paste(muntemp$Ano))
muntempl[[1]]$Perc=(muntempl[[1]]$x)/(sum(muntempl[[1]]$x))
muntempl[[1]]$Perc=muntempl[[1]]$Perc*100
muntempl[[2]]$Perc=(muntempl[[2]]$x)/(sum(muntempl[[2]]$x))
muntempl[[2]]$Perc=muntempl[[2]]$Perc*100
municipios=readShapeSpatial("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Shapefiles/municipios_2010/municipios_2010.shp")
library(maptools)
#Malha de municípios
municipios=readShapeSpatial("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Shapefiles/municipios_2010/municipios_2010.shp")
estados=readShapeSpatial("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Shapefiles/estados_2010/estados_2010.shp")
#Selecionar apenas os municípios que pertencem ao estado de SP
spmunicipios=municipios
spmunicipios=spmunicipios[order(spmunicipios@data$uf),]
spmunicipios@data$Cod=1:length(municipios@data$id)
spmunicipios=spmunicipios[c(4781:5425),]
#Selecionar apenas o shape do estado de SP
spestado=estados
spestado=spestado[c(26),]
###########################################################
#Mapa de valor da produção de cultura permanente em 1994
spmunper1994=spmunicipios
dados=spmunper1994@data
dados$ordem=1:(dim(dados)[1])
dadosp1994=merge(dados,munperml[[1]],by.x=c('codigo_ibg'),by.y=c('Municipio'),all.x=T,all.y=T)
dadosp1994$cor[dadosp1994$Perc<0.5|is.na(dadosp1994$Perc)]="gold"
dadosp1994$cor[dadosp1994$Perc>=0.5&dadosp1994$Perc<1.5]="orange"
dadosp1994$cor[dadosp1994$Perc>=1.5&dadosp1994$Perc<3]="darkorange3"
dadosp1994$cor[dadosp1994$Perc>=3]="red"
dadosp1994=dadosp1994[order(dadosp1994$ordem),]
##################Mapa de circulos proporcionais
library(ggmap)
coords=coordinates(spmunper1994)
vp1994=cbind(dadosp1994,coords)
colnames(vp1994)[14]="lat"
colnames(vp1994)[15]="lon"
colnames(vp1994)[11]="Vperm1994"
mapsp=get_map(location = c(lat=-22,lon=-48.5),zoom=6,scale=1)
ggmap(mapsp)
mapPoints <- ggmap(mapsp) +  geom_point(aes(x = lat, y = lon, size = Vperm1994), data = vp1994, alpha = 0.5,color="darkgreen")
mapPoints
mapPointsLegend <- mapPoints  + scale_size(breaks = c(0, 5000, 10000, 25000, 50000, 75000), labels = c(0, 5, 10, 25, 50, 75), name = "Value 1994")
mapPointsLegend
######Mapa coroplético
dadosp1994=dadosp1994[,c(2:7,1,12,13)]
spmunper1994@data=dadosp1994
plot(spmunper1994, border=T,lwd=.1, axes=T,las=1,col=spmunper1994@data$cor)
plot(spestado,add=TRUE,lwd=0.8)
legenda=as.character(c("<0.5%","0.5%-1.5%","1.5%-3%","3%-3.5%"))
cores=as.character(c("gold","orange","darkorange3","red"))
legend(x=-46.3,y=-20.5, legenda, fill=cores, bty="s", title="Percentage", cex=0.7 )
#Adicionando escala ao mapa
library(maps)
map.scale(x=-47.5, y=-24.9,relwidth=0.07,metric=T,ratio=F,cex=0.7)
source(compassRose(-46.75,-24.55))
############################################
#Mapa de valor da produção de cultura permanente em 2014
spmunper2014=spmunicipios
dados=spmunper2014@data
dados$ordem=1:(dim(dados)[1])
dadosp2014=merge(dados,munperml[[2]],by.x=c('codigo_ibg'),by.y=c('Municipio'),all.x=T,all.y=T)
dadosp2014$cor[dadosp2014$Perc<0.5|is.na(dadosp2014$Perc)]="gold"
dadosp2014$cor[dadosp2014$Perc>=0.5&dadosp2014$Perc<1.5]="orange"
dadosp2014$cor[dadosp2014$Perc>=1.5&dadosp2014$Perc<3]="darkorange3"
#dadosp2014$cor[dadosp2014$Perc>=3]="red"
dadosp2014=dadosp2014[order(dadosp2014$ordem),]
##Mapa de círculos proporcionais
library(ggmap)
coords=coordinates(spmunper2014)
vp2014=cbind(dadosp2014,coords)
colnames(vp2014)[14]="lat"
colnames(vp2014)[15]="lon"
colnames(vp2014)[11]="Vperm2014"
mapsp=get_map(location = c(lat=-22,lon=-48.5),zoom=6,scale=1)
ggmap(mapsp)
mapPoints <- ggmap(mapsp) +  geom_point(aes(x = lat, y = lon, size = Vperm2014), data = vp2014, alpha = 0.5,color="darkgreen")
mapPoints
mapPointsLegend <- mapPoints  + scale_size(breaks = c(0, 25000, 50000, 100000, 150000, 255000), labels = c(0, 25, 50, 100, 150, 255), name = "Value 2014")
mapPointsLegend
################Mapa coroplético
dadosp2014=dadosp2014[,c(2:7,1,12,13)]
spmunper2014@data=dadosp2014
plot(spmunper2014, border=T,lwd=.1, axes=F,las=1,col=spmunper2014@data$cor)
plot(spestado,add=TRUE,lwd=0.8)
legenda=as.character(c("<0.5%","0.5%-1.5%","1.5%-3%"))
cores=as.character(c("gold","orange","darkorange3"))
legend(x=-46.3,y=-20.5, legenda, fill=cores, bty="s", title="Percentage", cex=0.7 )
#Adicionando escala ao mapa
library(maps)
map.scale(x=-47.5, y=-24.9,relwidth=0.07,metric=T,ratio=F,cex=0.7)
source(compassRose(-46.75,-24.55))
#Mapa de valor da produção de cultura temporária em 1994
spmuntemp1994=spmunicipios
dados=spmuntemp1994@data
dados$ordem=1:(dim(dados)[1])
dadost1994=merge(dados,muntempl[[1]],by.x=c('codigo_ibg'),by.y=c('Municipio'),all.x=T,all.y=T)
dadost1994$cor[dadost1994$Perc<0.5|is.na(dadost1994$Perc)]="gold"
dadost1994$cor[dadost1994$Perc>=0.5&dadost1994$Perc<1.5]="orange"
dadost1994$cor[dadost1994$Perc>=1.5&dadost1994$Perc<3]="darkorange3"
#dadosp1994$cor[dadosp1994$Perc>=3]="red"
dadost1994=dadost1994[order(dadost1994$ordem),]
##Mapa de círculos proporcionais
library(ggmap)
coords=coordinates(spmuntemp1994)
vt1994=cbind(dadost1994,coords)
colnames(vt1994)[14]="lat"
colnames(vt1994)[15]="lon"
colnames(vt1994)[11]="Vtemp1994"
mapsp=get_map(location = c(lat=-22,lon=-48.5),zoom=6,scale=1)
ggmap(mapsp)
mapPoints <- ggmap(mapsp) +  geom_point(aes(x = lat, y = lon, size = Vtemp1994), data = vt1994, alpha = 0.5,color="springgreen4")
mapPoints
mapPointsLegend <- mapPoints  + scale_size(breaks = c(0, 5000, 10000, 25000, 50000, 70000), labels = c(0, 5, 10, 25, 50, 70), name = "Value 1994")
mapPointsLegend
#Tratamento do IPCA
ipca=read.csv("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/IPCA/IPCA/IPCA.csv",header=T)
ipca=ipca[c(15:36),c(1,2)]
colnames(ipca)[2]="IPCA"
ipca$V1=((ipca$IPCA/100)+1)
#Valores reais de 1994. Divido o valor monetário por esse número
ipca$V2[1]=1
ipca$V2[2]=ipca$V1[2]
for (i in 3:length(ipca$V1)){
ipca$V2[i]=(ipca$V2[i-1])*(ipca$V1[i])
}
#Valores reais de 2014. Multiplico o valor monetário po esse número
ipca$V3[22]=1
ipca$V3[21]=ipca$V1[21]
for(i in (length(ipca$V1)-2):1){
ipca$V3[i]=(ipca$V3[i+1])*(ipca$V1[i])
}
ipca=read.csv("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/IPCA/IPCA/IPCA.csv",header=T)
ipca=read.csv("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/IPCA/IPCA.csv",header=T)
ipca=ipca[c(15:36),c(1,2)]
colnames(ipca)[2]="IPCA"
ipca$V1=((ipca$IPCA/100)+1)
#Valores reais de 1994. Divido o valor monetário por esse número
ipca$V2[1]=1
ipca$V2[2]=ipca$V1[2]
for (i in 3:length(ipca$V1)){
ipca$V2[i]=(ipca$V2[i-1])*(ipca$V1[i])
}
#Valores reais de 2014. Multiplico o valor monetário po esse número
ipca$V3[22]=1
ipca$V3[21]=ipca$V1[21]
for(i in (length(ipca$V1)-2):1){
ipca$V3[i]=(ipca$V3[i+1])*(ipca$V1[i])
}
load("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Dados climáticos/climafinalanosp.RData")
#carrega dados por estação do ano
load("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Dados climáticos/climafinalestsp.RData")
areaculttemp=read.csv("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Lavoura permanente/area_colhida_lavoura_temporaria.csv",
header=T,na.strings = c("-","NA"))
###Carrega dados de área e de valor da produção de culturas temporárias
areaculttemp=read.csv("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Lavoura permanente/area_colhida_lavoura_temporaria.csv",
header=T,na.strings = c("-","NA"))
###Carrega dados de área e de valor da produção de culturas temporárias
areaculttemp=read.csv("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Lavoura temporária/area_colhida_lavoura_temporaria.csv",
header=T,na.strings = c("-","NA"))
vculttemp=read.csv("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Lavoura temporária/vptemporario.csv",
header=T, na.strings = c("-","NA"))
###Padronização dos períodos da base de dados
vculttemp=vculttemp[vculttemp$Ano>=1994,]
ipca=ipca[ipca$Data<2015,]
climafinalanosp=climafinalanosp[climafinalanosp$Ano>=1994,]
climafinalanosp=climafinalanosp[,c(1,4:18)]
climafinalestsp=climafinalestsp[climafinalestsp$Ano>=1994,]
climafinalestsp=climafinalestsp[,c(1,3:59)]
#######Deflacionando série de dados
lvculttemp2=list()
lvculttemp=split(vculttemp, paste(vculttemp$Municipio))
for (i in 1:length(lvculttemp)){
temp=cbind(lvculttemp[[i]]$Municipio,lvculttemp[[i]]$Ano,lvculttemp[[i]]$VPTemporario/ipca$V2)
colnames(temp)=c("Municipio","Ano","VTReal")
lvculttemp2[[i]]=temp
}
vculttemp=do.call(rbind.data.frame,lvculttemp2)
vculttemp$logreal=log(vculttemp$VTReal)
vculttemp$logreal[!is.finite(vculttemp$logreal)]=NA
#Padronizando data de área colhida e aplicando log
areaculttemp=areaculttemp[areaculttemp$Ano>=1994,]
areaculttemp$logarea=log(areaculttemp$Area.Colhida)
areaculttemp$logarea[!is.finite(areaculttemp$logarea)]=NA
#merge tables
vculttemp=merge(vculttemp,areaculttemp,by.x=c('Municipio','Ano'),by.y=c('Município','Ano'))
vculttemp=merge(vculttemp,climafinalanosp, by.x=c('Municipio','Ano'),by.y=c('Codigo','Ano'),all.x=T,all.y=F)
vculttemp=merge(vculttemp,climafinalestsp, by.x=c('Municipio','Ano'),by.y=c('Codigo','Ano'),all.x=T,all.y=F)
#Tenho que atribuir binária para os municípios da bacia do rio
#jundiaí: Salto (3545209), Itupeva (3524006), Jundiaí (3525904),
# Varzea Paulista (3556503), Campo Limpo Paulista (3509601),Mairiporã (3528502)
#não estão presentes
#Varzea Paulista (3556503) 1994-2010
#Campo Limpo Paulista (3509601) 1995-2010 (mas há problemas com os dados entre 2001-2009. todos os anos tem valor 1)
#Mairiporã (3528502) 1994,1995,2000 (série bem incompleta)
#ACho que vou manter a seŕie entre 1994 e 2014 apenas com Salto,
#Jundiaí e Itupeva. Não compensa alterar todo o banco de dados apenas por
#causa de três municípios com problemas de dados
#Vou atribuir binárias aos três municípios logo antes de rodar o painel
#O painel de dados tem que necessariamente ser balanceado para que eu consiga fazer regressão espacial.
#o que eu posso fazer é deixar apenas os municípios presentes em todos os anos da série
lvculttemp=split(vculttemp,paste(vculttemp$Municipio))
lvculttemp2=list()
j=1
for (i in 1:length(lvculttemp)){
lvculttemp[[i]]$TesteNA=0
lvculttemp[[i]]$TesteNA[is.na(lvculttemp[[i]]$logreal)]=1
if(sum(lvculttemp[[i]]$TesteNA)==0){
lvculttemp2[j]=lvculttemp[i]
j=j+1
}
}
vculttemp=do.call(rbind.data.frame,lvculttemp2)
municipios=readShapeSpatial("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Shapefiles/municipios_2010/municipios_2010.shp")
library(maptools)
#Selecionar apenas os municípios que pertencem ao estado de SP
spmunicipios=municipios
spmunicipios=spmunicipios[order(spmunicipios@data$uf),]
spmunicipios@data$Cod=1:length(municipios@data$id)
spmunicipios=spmunicipios[c(4781:5425),]
#Exlui Ilha Bela do litoral de São Paulo. Com nã havia conexões com o continente
#estava dando problema na hora de criar a matrix de pesos.
spmunicipios2014=spmunicipios[c(1:12,14:645),]
munpanel=vculttemp[vculttemp$Ano==2014,]
#Não vai ser só ilha bela
#Tenho que excluir todos os municípios que não estão presentes no painel de dados
#Atribuindo 1 a variável bin para os elementos que estão presentes em munpanel e spmunicipios2014 simultaneamente
spmunicipios2014$bin=0
for (i in 1:length(spmunicipios2014$codigo_ibg)){
for (j in 1:length(munpanel$Municipio)){
if (spmunicipios2014$codigo_ibg[[i]]==munpanel$Municipio[[j]]){
spmunicipios2014$bin[[i]]=1
}
}
}
#Pegando em spmunicipios2014 apenas os elementos com valor de bin =1  e atribuindo novamente a spmunicipios2014
spmunicipios2014=spmunicipios2014[spmunicipios2014$bin==1,]
library(spdep)
#Cria neighbors por contiguidade
spneighbors=poly2nb(spmunicipios2014)
coords=coordinates(spmunicipios2014)
#Plotanto mapa de vizinhança
plot(spneighbors,coords,col="black")
#####Spatial weight matrix based on contiguity
weigthmatrix=nb2listw(spneighbors)
summary(weigthmatrix)
#library(Hmisc)
#moranI=round(moranI,4)
#setwd("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP")
#latex(moranI,rowname = NULL)
#Lagrange multiplier test for spatial lag and spatial error dependencies
#De acordo com os p-values nós temos dependência espacial e também podemos
#usar modelo com lag e com erro espacial
#lm.LMtests(logareal[[1]]$logreal,weigthmatrix,test=c("LMlag","LMerr"))
#Tenho que atribuir binária para os municípios da bacia do rio
#jundiaí: Salto (3545209), Itupeva (3524006), Jundiaí (3525904),
vculttemp$bjundiai=0
vculttemp$bjundiai[vculttemp$Municipio==3545209|vculttemp$Municipio==3524006|vculttemp$Municipio==3525904]=1
library(plm)
library(splm)
vculttemp=plm.data(vculttemp)
Y=cbind(vculttemp[,c(4)])
#melhor ajuste até o momento
#X=as.matrix(vculttemp[,c(11,8,10,13)])
#Problema com a binária 78
X=as.matrix(vculttemp[,c(8,10,13,32,78)])
fm=Y~X
######################
#Testes Lagrange multiplier
LM1=bsktest(x=fm,data=vculttemp,listw=weigthmatrix,test="LM1")
LM1
LM2=bsktest(x=fm,data=vculttemp,listw=weigthmatrix,test="LM2")
LM2
LMH=bsktest(x=fm,data=vculttemp,listw=weigthmatrix,test="LMH")
LMH
CLMlambda=bsktest(x=fm,data=vculttemp,listw=weigthmatrix,test="CLMlambda")
CLMlambda
##################
#Efeitos fixos e aleatórios não espacial + teste de hausmann
fe=plm(formula=fm,data=vculttemp,model="within")
summary(fe)
re=plm(formula=fm,data=vculttemp,model="random")
summary(re)
phtest(re, fe)
#Modelos espaciais de efeitos fixo e efeitos aleatórios sem erro espacial e
#sem lag +  teste de hausman
fe=spgm(formula=fm,data=vculttemp,index=NULL,listw=weigthmatrix, model="within")
summary(fe)
re=spgm(formula=fm,data=vculttemp,index=NULL,listw=weigthmatrix, model="random")
summary(re)
sphtest(x = re, x2 = fe)
#Modelos espaciais de efeitos fixo e efeitos aleatórios com erro espacial e
#sem lag +  teste de hausman
fe=spgm(formula=fm,data=vculttemp,index=NULL,listw=weigthmatrix, model="within",spatial.error = T)
summary(fe)
re=spgm(formula=fm,data=vculttemp,index=NULL,listw=weigthmatrix, model="random",spatial.error = T)
summary(re)
sphtest(x = re, x2 = fe)
#Modelos espaciais de efeitos fixo e efeitos aleatórios sem erro espacial e
#com lag +  teste de hausman
fe=spgm(formula=fm,data=vculttemp,index=NULL,listw=weigthmatrix, model="within",lag=T)
summary(fe)
re=spgm(formula=fm,data=vculttemp,index=NULL,listw=weigthmatrix, model="random",lag=T)
summary(re)
sphtest(x = re, x2 = fe)
#Modelos espaciais de efeitos fixo e efeitos aleatórios com erro espacial e
#com lag +  teste de hausman
fe=spgm(formula=fm,data=vculttemp,index=NULL,listw=weigthmatrix, model="within",lag=T, spatial.error = T)
summary(fe)
re=spgm(formula=fm,data=vculttemp,index=NULL,listw=weigthmatrix, model="random",lag=T,spatial.error = T)
summary(re)
sphtest(x = re, x2 = fe)
ipca=read.csv("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/IPCA/IPCA.csv",header=T)
ipca=ipca[c(15:36),c(1,2)]
colnames(ipca)[2]="IPCA"
ipca$V1=((ipca$IPCA/100)+1)
#Valores reais de 1994. Divido o valor monetário por esse número
ipca$V2[1]=1
ipca$V2[2]=ipca$V1[2]
for (i in 3:length(ipca$V1)){
ipca$V2[i]=(ipca$V2[i-1])*(ipca$V1[i])
}
#Valores reais de 2014. Multiplico o valor monetário po esse número
ipca$V3[22]=1
ipca$V3[21]=ipca$V1[21]
for(i in (length(ipca$V1)-2):1){
ipca$V3[i]=(ipca$V3[i+1])*(ipca$V1[i])
}
load("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Dados climáticos/climafinalanosp.RData")
#carrega dados por estação do ano
load("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Dados climáticos/climafinalestsp.RData")
vcultperm=read.csv("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Lavoura permanente/vppermanente.csv",
header=T,na.strings=c("-","NA"))
###Padronização dos períodos da base de dados
vcultperm=vcultperm[vcultperm$Ano>=1994,]
ipca=ipca[ipca$Data<2015,]
climafinalanosp=climafinalanosp[climafinalanosp$Ano>=1994,]
climafinalanosp=climafinalanosp[,c(1,4:18)]
climafinalestsp=climafinalestsp[climafinalestsp$Ano>=1994,]
climafinalestsp=climafinalestsp[,c(1,3:59)]
#######Deflacionando série de dados
lvcultperm2=list()
lvcultperm=split(vcultperm, paste(vcultperm$Município))
for (i in 1:length(lvcultperm)){
perm=cbind(lvcultperm[[i]]$Município,lvcultperm[[i]]$Ano,lvcultperm[[i]]$VPPermanente/ipca$V2)
colnames(perm)=c("Municipio","Ano","VPReal")
lvcultperm2[[i]]=perm
}
vcultperm=do.call(rbind.data.frame,lvcultperm2)
vcultperm$logreal=log(vcultperm$VPReal)
vcultperm$logreal[!is.finite(vcultperm$logreal)]=NA
#merge tables
vcultperm=merge(vcultperm,climafinalanosp, by.x=c('Municipio','Ano'),by.y=c('Codigo','Ano'),all.x=T,all.y=F)
vcultperm=merge(vcultperm,climafinalestsp, by.x=c('Municipio','Ano'),by.y=c('Codigo','Ano'),all.x=T,all.y=F)
#O painel de dados tem que necessariamente ser balanceado para que eu consiga fazer regressão espacial.
#o que eu posso fazer é deixar apenas os municípios presentes em todos os anos da série
lvcultperm=split(vcultperm,paste(vcultperm$Municipio))
lvcultperm2=list()
j=1
for (i in 1:length(lvcultperm)){
lvcultperm[[i]]$TesteNA=0
lvcultperm[[i]]$TesteNA[is.na(lvcultperm[[i]]$logreal)]=1
if(sum(lvcultperm[[i]]$TesteNA)==0){
lvcultperm2[j]=lvcultperm[i]
j=j+1
}
}
vcultperm=do.call(rbind.data.frame, lvcultperm2)
municipios=readShapeSpatial("/home/bmiyamoto/Documentos/Pesquisa/Artigo VBPSP/Gori/Dados/Shapefiles/municipios_2010/municipios_2010.shp")
#Selecionar apenas os municípios que pertencem ao estado de SP
spmunicipios=municipios
spmunicipios=spmunicipios[order(spmunicipios@data$uf),]
spmunicipios@data$Cod=1:length(municipios@data$id)
spmunicipios=spmunicipios[c(4781:5425),]
#Exlui Ilha Bela do litoral de São Paulo. Com nã havia conexões com o continente
#estava dando problema na hora de criar a matrix de pesos.
spmunicipios2014=spmunicipios[c(1:12,14:645),]
#Não vai ser só ilha bela
#Tenho que excluir todos os municípios que não estão presentes no painel de dados
#Atribuindo 1 a variável bin para os elementos que estão presentes em munpanel e spmunicipios2014 simultaneamente
munpanel=vcultperm[vcultperm$Ano==2014,]
spmunicipios2014$bin=0
for (i in 1:length(spmunicipios2014$codigo_ibg)){
for (j in 1:length(munpanel$Municipio)){
if (spmunicipios2014$codigo_ibg[[i]]==munpanel$Municipio[[j]]){
spmunicipios2014$bin[[i]]=1
}
}
}
#Pegando em spmunicipios2014 apenas os elementos com valor de bin =1  e atribuindo novamente a spmunicipios2014
spmunicipios2014=spmunicipios2014[spmunicipios2014$bin==1,]
library(spdep)
#Cria neighbors por contiguidade
spneighbors=poly2nb(spmunicipios2014)
coords=coordinates(spmunicipios2014)
#Plotanto mapa de vizinhança
plot(spneighbors,coords,col="black")
#Tentei editar a lista para ligar pontos desconexos
#edit.nb(spneighbors,coords)
#####Spatial weight matrix based on contiguity
#Como não consegui editar usei o argumento zero policy
#nem edit.nb ou zero policy funcionaram
#Peo que eu entendi esse comando cria a matriz de pesos pelas coordenadas, ao invés de usar
#a vizinhança. Usa coordenadas a uma distânai de 45 km
weigthmatrix=dnearneigh(coords,0,45,longlat = T)
weigthmatrix=nb2listw(weigthmatrix)
summary(weigthmatrix)
#Tenho que atribuir binária para os municípios da bacia do rio
#jundiaí: Salto (3545209), Itupeva (3524006), Jundiaí (3525904),
# Varzea Paulista (3556503), Campo Limpo Paulista (3509601),Mairiporã (3528502)
vcultperm$bjundiai=0
vcultperm$bjundiai[vcultperm$Municipio==3528502|vcultperm$Municipio==3509601|vcultperm$Municipio==3556503|vcultperm$Municipio==3545209|vcultperm$Municipio==3524006|vcultperm$Municipio==3525904]=1
library(plm)
library(splm)
vcultperm=plm.data(vcultperm)
Y=as.matrix(vcultperm[,c(4)])
#melhor ajuste até o momento
X=as.matrix(vcultperm[,c(6,8,11,16,76)])
#Problema com a binária 78
#X=as.matrix(vculttemp[,c(11,8,10,13,78)])
fm=Y~X
######################
#Testes Lagrange multiplier
LM1=bsktest(x=fm,data=vcultperm,listw=weigthmatrix,test="LM1")
LM1
LM2=bsktest(x=fm,data=vcultperm,listw=weigthmatrix,test="LM2")
LM2
LMH=bsktest(x=fm,data=vcultperm,listw=weigthmatrix,test="LMH")
LMH
CLMlambda=bsktest(x=fm,data=vcultperm,listw=weigthmatrix,test="CLMlambda")
CLMlambda
###################
#Efeitos fixos e aleatórios não espacial + teste de hausmann
fe=plm(formula=fm,data=vcultperm,model="within")
summary(fe)
re=plm(formula=fm,data=vcultperm,model="random")
summary(re)
phtest(re, fe)
#Modelos espaciais de efeitos fixo e efeitos aleatórios sem erro espacial e
#sem lag +  teste de hausman
fe=spgm(formula=fm,data=vcultperm,index=NULL,listw=weigthmatrix, model="within")
summary(fe)
re=spgm(formula=fm,data=vcultperm,index=NULL,listw=weigthmatrix, model="random")
summary(re)
sphtest(x = re, x2 = fe)
#Modelos espaciais de efeitos fixo e efeitos aleatórios com erro espacial e
#sem lag +  teste de hausman
fe=spgm(formula=fm,data=vcultperm,index=NULL,listw=weigthmatrix, model="within",spatial.error = T)
summary(fe)
re=spgm(formula=fm,data=vcultperm,index=NULL,listw=weigthmatrix, model="random",spatial.error = T)
summary(re)
sphtest(x = re, x2 = fe)
#Modelos espaciais de efeitos fixo e efeitos aleatórios sem erro espacial e
#com lag +  teste de hausman
fe=spgm(formula=fm,data=vcultperm,index=NULL,listw=weigthmatrix, model="within",lag=T)
summary(fe)
re=spgm(formula=fm,data=vcultperm,index=NULL,listw=weigthmatrix, model="random",lag=T)
summary(re)
sphtest(x = re, x2 = fe)
#Modelos espaciais de efeitos fixo e efeitos aleatórios com erro espacial e
#com lag +  teste de hausman
fe=spgm(formula=fm,data=vcultperm,index=NULL,listw=weigthmatrix, model="within",lag=T, spatial.error = T)
summary(fe)
re=spgm(formula=fm,data=vcultperm,index=NULL,listw=weigthmatrix, model="random",lag=T,spatial.error = T)
summary(re)
sphtest(x = re, x2 = fe)
install.packages('plm')
install.packages('plm')
install.packages("plm")
